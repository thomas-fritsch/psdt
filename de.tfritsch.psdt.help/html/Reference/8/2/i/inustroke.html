<!DOCTYPE html>
<html>
<head>
<title>inustroke</title>
</head>
<body>
	<b>inustroke </b> LEVEL 2
	<pre>              x y userpath <b>inustroke</b> bool
       x y userpath matrix <b>inustroke</b> bool
       userpath1 userpath2 <b>inustroke</b> bool
userpath1 userpath2 matrix <b>inustroke</b> bool</pre>
	<p>
		The first form returns <a href="../t/true.html">true</a> if the device
		pixel containing the point (x, y) in user space would be painted by a
		<a href="../u/ustroke.html">ustroke</a> applied to the same operands.
		Otherwise it returns <a href="../f/false.html">false</a>.
	</p>
	<p>
		In the second form, inustroke concatenates matrix to the CTM after
		interpreting the user paths, but before computing the stroke (see <a
			href="../u/ustroke.html">ustroke</a> operator).
	</p>
	<p>
		In the third and fourth forms, the device pixels that would be painted
		by filling userpath1 become an &quot;aperture.&quot; inustroke returns
		true if any of the pixels in the aperture would be painted by a <a
			href="../u/ustroke.html">ustroke</a> of userpath2. Otherwise it
		returns false.
	</p>
	<p>
		This operator does not place any marks on the current page nor does it
		disturb the current path in the graphics state. Except for the manner
		in which the path is specified, inustroke behaves the same as <a
			href="instroke.html">instroke</a>.
	</p>
	<p>
		As with <a href="inufill.html">inufill</a>, if userpath is already
		present in the user path cache, inustroke can take advantage of the
		cached information to optimize execution.
	</p>
	<p>
		<b>Errors:</b> <a href="invalidaccess.html">invalidaccess</a>, <a
			href="../l/limitcheck.html">limitcheck</a>, <a
			href="../r/rangecheck.html">rangecheck</a>, <a
			href="../s/stackunderflow.html">stackunderflow</a>, <a
			href="t.html#typecheck">typecheck</a>
	</p>
	<p>
		<b>See Also:</b> <a href="../s/stroke.html">stroke</a>, <a
			href="../u/ustroke.html">ustroke</a>, <a href="instroke.html">instroke</a>
	</p>
</body>
</html>
