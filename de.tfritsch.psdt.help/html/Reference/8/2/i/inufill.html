<!DOCTYPE html>
<html>
<head>
<title>inufill</title>
</head>
<body>
	<h3>inufill [LEVEL 2]</h3>
	<pre>       x y userpath <b>inufill</b> bool
userpath1 userpath2 <b>inufill</b> bool</pre>
	<p>
		The first form returns <a href="t.html#true">true</a> if the device
		pixel containing the point (x, y) in user space would be painted by a
		<a href="u.html#ufill">ufill</a> of the specified userpath .
		Otherwise, it returns <a href="f.html#false">false</a>.
	</p>
	<p>
		In the second form, the device pixels that would be painted by filling
		userpath1 become an &quot;aperture.&quot; inufill returns true if any
		of the pixels in the aperture would be painted by a <a
			href="u.html#ufill">ufill</a> of userpath2. Otherwise, it returns
		false.
	</p>
	<p>
		This operator does not place any marks on the current page nor does it
		disturb the current path in the graphics state. Except for the manner
		in which the path is specified, inufill behaves the same as <a
			href="#infill">infill</a>.
	</p>
	<p>By itself, this operator is seemingly a trivial composition of
		several other operators:</p>
	<pre>
gsave
  newpath
  uappend
  infill
grestore
</pre>
	<p>
		However, when used with a user path that specifies <a
			href="../u/ucache.html">ucache</a>, inufill can access the user path
		cache, potentially resulting in improved performance.
	</p>
	<p>
		<b>Errors:</b> <a href="invalidaccess.html">invalidaccess</a>, <a
			href="../l/limitcheck.html">limitcheck</a>, <a
			href="../r/rangecheck.html">rangecheck</a>, <a
			href="../s/stackunderflow.html">stackunderflow</a>, <a
			href="../t/typecheck.html">typecheck</a>
	</p>
	<p>
		<b>See Also:</b> <a href="inueofill.html">inueofill</a>, <a
			href="infill.html">infill</a>, <a href="../u/ufill.html">ufill</a>
	</p>
</body>
</html>
