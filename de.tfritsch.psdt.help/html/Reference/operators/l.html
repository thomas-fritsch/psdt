<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<!-- This HTML document was generated by David Burch -->
<HEAD>
    <TITLE>Postscript Level 2</TITLE>
</HEAD>
<BODY>
<H1>Postscript Operators 'L'</H1>
<HR>
<A NAME="languagelevel"></A>
<B>languagelevel</B> LEVEL 2
<PRE>- languagelevel int</PRE>
<P>
is an integer designating the PostScript language level supported by the
PostScript interpreter. If the value of languagelevel is 2, the PostScript
interpreter supports all PostScript Level 2 language features.
If the value of languagelevel is 1 or if languagelevel is not defined in
<A HREF="s.html#systemdict">systemdict</A>, the PostScript interpreter
does not support all PostScript Level 2 language features.
<P>
<B>Errors:</B> <A HREF="s.html#stackoverflow">stackoverflow</A>, <A HREF="u.html#undefined">undefined</A>
<P>
<B>See Also:</B> <A HREF="p.html#product">product</A>, <A HREF="qr.html#revision">revision</A>,
<A HREF="s.html#serialnumber">serialnumber</A>, <A HREF="v.html#version">version</A>
<HR>
<A NAME="le"></A>
<B>le</B>
<PRE>      num1 num2 le bool
string1 string2 le bool</PRE>
<P>
pops two objects from the operand stack and pushes the boolean value true
if the first operand is less than or equal to the second, false otherwise.
If both operands are numbers, le compares their mathematical values. If
both operands are strings, le compares them element by element (treating
the elements as integers in the range 0 to 255) to determine whether the
first string is lexically less than or equal to the second. If the operands
are of other types or one is a string and the other is a number, le executes
the <A HREF="t.html#typecheck">typecheck</A> error.
<P>
<B>Errors:</B> <A HREF="ik.html#invalidaccess">invalidaccess</A>, <A HREF="s.html#stackunderflow">stackunderflow</A>,
<A HREF="t.html#typecheck">typecheck</A>
<P>
<B>See Also:</B> <A HREF="#lt">lt</A>, <A HREF="e.html#eq">eq</A>, <A HREF="no.html#ne">ne</A>,
<A HREF="gh.html#ge">ge</A>, <A HREF="gh.html#gt">gt</A>
<HR>
<A NAME="length"></A>
<B>length</B>
<PRE>      array length int
packedarray length int
       dict length int
     string length int
       name length int</PRE>
<P>
depends on the type of its operand. If the operand is an <A HREF="a.html#array">array</A>,
packed array, or string, length returns the number of elements in its value.
If the operand is a dictionary, length returns the current number of key-value
pairs it contains, as opposed to its maximum capacity, which is returned
by <A HREF="m.html#maxlength">maxlength</A>. If the operand is a name
object, the length is the number of characters in the text string that defines
it.
<P>
<B>Examples</B>
<PRE>
[1 2 4] length                      &rArr;  3
[] length                           &rArr;  0    % An array of zero length
/ar 20 array def
ar length                           &rArr;  20

/mydict 5 dict def
mydict length                       &rArr;  0
mydict /firstkey (firstvalue) put
mydict length                       &rArr;  1

(abc\n) length                      &rArr;  4    % Newline )\n) is one character
() length                           &rArr;  0    % No characters between ( and )
/foo length                         &rArr;  3
</PRE>
<P>
<B>Errors:</B> <A HREF="ik.html#invalidaccess">invalidaccess</A>, <A HREF="s.html#stackunderflow">stackunderflow</A>,
<A HREF="t.html#typecheck">typecheck</A>
<P>
<B>See Also:</B> <A HREF="m.html#maxlength">maxlength</A>
<HR>
<A NAME="limitcheck"></A>
<B>limitcheck</B> (error)
<P>
An implementation limit has been exceeded
(for example, too many files have been opened simultaneously or a path has
become too complex).
<HR>
<A NAME="lineto"></A>
<B>lineto</B>
<PRE>x y lineto</PRE>
<P>
appends a straight line segment to the current path . The line extends
from the current point to the point (x, y) in user space; (x, y) then becomes
the current point. If the current point is undefined because the current
path is empty, lineto executes the error <A HREF="no.html#nocurrentpoint">nocurrentpoint</A>.
<P>
<B>Errors:</B> <A HREF="#limitcheck">limitcheck</A>, <A HREF="no.html#nocurrentpoint">nocurrentpoint</A>,
<A HREF="s.html#stackunderflow">stackunderflow</A>, <A HREF="t.html#typecheck">typecheck</A>
<P>
<B>See Also:</B> <A HREF="qr.html#rlineto">rlineto</A>, <A HREF="m.html#moveto">moveto</A>,
<A HREF="a.html#arc">arc</A>, <A HREF="c.html#curveto">curveto</A>,
<A HREF="c.html#closepath">closepath</A>
<HR>
<A NAME="ln"></A>
<B>ln</B>
<PRE>num ln real</PRE>
<P>
returns the natural logarithm (base e) of num. The result is a real.
<P>
<B>Examples</B>
<PRE>
10 ln    &rArr;  2.30259
100 ln   &rArr;  4.60517
</PRE>
<P>
<B>Errors:</B> <A HREF="qr.html#rangecheck">rangecheck</A>, <A HREF="s.html#stackunderflow">stackunderflow</A>,
<A HREF="t.html#typecheck">typecheck</A>
<P>
<B>See Also:</B> <A HREF="#log">log</A>, <A HREF="e.html#exp">exp</A>
<HR>
<A NAME="load"></A>
<B>load</B>
<PRE>key load value</PRE>
<P>
searches for key in each dictionary on the dictionary stack, starting with
the topmost (current) dictionary. If key is found in some dictionary, load
pushes the associated value on the operand stack. If key is not found in
any dictionary on the dictionary stack, load executes the error <A HREF="u.html#undefined">undefined</A>.
<P>
load looks up key the same way the interpreter looks up executable names
that it encounters during execution. However, load always pushes the associated
value on the operand stack; it never executes that value.
<P>
<B>Example</B>
<PRE>
/avg {add 2 div} def
/avg load            &rArr;  {add 2 div}
</PRE>
<P>
<B>Errors:</B> <A HREF="ik.html#invalidaccess">invalidaccess</A>, <A HREF="s.html#stackunderflow">stackunderflow</A>,
<A HREF="t.html#typecheck">typecheck</A>, <A HREF="u.html#undefined">undefined</A>
<P>
<B>See Also:</B> <A HREF="w.html#where">where</A>, <A HREF="gh.html#get">get</A>,
<A HREF="s.html#store">store</A>
<HR>
<A NAME="lock"></A>
<B>lock</B> DPS
<PRE>- lock lock</PRE>
<P>
creates a new lock object, unequal to any lock object already in existence,
and pushes it on the operand stack. The state of the lock is initially free.
<P>
Since a lock is a composite object, creating one consumes VM. The lock's
value is allocated in local or global VM according to the current VM allocation
mode.
<P>
<B>Errors:</B> <A HREF="s.html#stackoverflow">stackoverflow</A>, <A HREF="v.html#VMerror">VMerror</A>
<P>
<B>See Also:</B> <A HREF="m.html#monitor">monitor</A>, <A HREF="w.html#wait">wait</A>
<HR>
<A NAME="log"></A>
<B>log</B>
<PRE>num log real</PRE>
<P>
returns the common logarithm (base 10) of num. The result is a real.
<P>
<B>Examples</B>
<PRE>
10 log   &rArr;  1.0
100 log  &rArr;  2.0
</PRE>
<P>
<B>Errors:</B> <A HREF="qr.html#rangecheck">rangecheck</A>, <A HREF="s.html#stackunderflow">stackunderflow</A>,
<A HREF="t.html#typecheck">typecheck</A>
<P>
<B>See Also:</B> <A HREF="#ln">ln</A>, <A HREF="e.html#exp">exp</A>
<HR>
<A NAME="loop"></A>
<B>loop</B>
<PRE>proc loop -</PRE>
<P>
repeatedly executes proc until proc executes the <A HREF="e.html#exit">exit</A>
operator, at which point interpretation resumes at the object next in sequence
after the loop. Control also leaves proc if the <A HREF="s.html#stop">stop</A>
operator is executed. If proc never executes <A HREF="e.html#exit">exit</A>
or <A HREF="s.html#stop">stop</A>, an infinite loop results, which can
be broken only via an external interrupt (see <A HREF="ik.html#interrupt">interrupt</A>).
<P>
<B>Errors:</B> <A HREF="s.html#stackunderflow">stackunderflow</A>, <A HREF="t.html#typecheck">typecheck</A>
<P>
<B>See Also:</B> <A HREF="f.html#for">for</A>, <A HREF="qr.html#repeat">repeat</A>,
<A HREF="f.html#forall">forall</A>, <A HREF="e.html#exit">exit</A>
<HR>
<A NAME="lt"></A>
<B>lt</B>
<PRE>      num1 num2 lt bool
string1 string2 lt bool</PRE>
<P>
pops two objects from the operand stack and pushes the boolean value true
if the first operand is less than the second, false otherwise. If both operands
are numbers, lt compares their mathematical values. If both operands are
strings, lt compares them element by element (treating the elements as integers
in the range 0 to 255) to determine whether the first string is lexically
less than the second. If the operands are of other types or one is a string
and the other is a number, lt executes the <A HREF="t.html#typecheck">typecheck</A>
error.
<P>
<B>Errors:</B> <A HREF="ik.html#invalidaccess">invalidaccess</A>, <A HREF="s.html#stackunderflow">stackunderflow</A>,
<A HREF="t.html#typecheck">typecheck</A>
<P>
<B>See Also:</B> <A HREF="#le">le</A>, <A HREF="e.html#eq">eq</A>, <A HREF="no.html#ne">ne</A>,
<A HREF="gh.html#ge">ge</A>, <A HREF="gh.html#gt">gt</A>
<HR>
</BODY>
</HTML>
